//StockEntity+CoreDataProperties.swift
import Foundation
import CoreData

extension StockEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<StockEntity> {
        return NSFetchRequest<StockEntity>(entityName: "StockEntity")
    }
    
    @NSManaged public var id: UUID?
    @NSManaged public var name: String?
    @NSManaged public var code: String?
    @NSManaged public var targetPercentage: Double
    @NSManaged public var currentPrice: Int64
    @NSManaged public var quantity: Int64
    @NSManaged public var category: String?
    @NSManaged public var dailyVariation: Double
}

extension StockEntity {
    /// Core Data의 StockEntity를 기존의 Stock 구조체로 변환
    var toStock: Stock {
        Stock(
            id: self.id ?? UUID(),
            name: self.name ?? "",
            code: self.code ?? "",
            targetPercentage: self.targetPercentage,
            currentPrice: Int(self.currentPrice),
            quantity: Int(self.quantity),
            category: self.category ?? "",
            dailyVariation: self.dailyVariation
        )
    }
    
    /// Stock 구조체의 값을 Core Data 객체에 반영
    func update(from stock: Stock) {
        self.id = stock.id
        self.name = stock.name
        self.code = stock.code
        self.targetPercentage = stock.targetPercentage
        self.currentPrice = Int64(stock.currentPrice)
        self.quantity = Int64(stock.quantity)
        self.category = stock.category
        self.dailyVariation = stock.dailyVariation
    }
}


//SettingsEntity+CoreDataClass.swift
import Foundation
import CoreData

@objc(SettingsEntity)
public class SettingsEntity: NSManagedObject {

}


//SettingsEntity+CoreDataProperties.swift
import Foundation
import CoreData

extension SettingsEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<SettingsEntity> {
        return NSFetchRequest<SettingsEntity>(entityName: "SettingsEntity")
    }
    
    @NSManaged public var cash: Double
    @NSManaged public var threshold: Double
}

extension SettingsEntity {
    /// SettingsEntity가 존재하지 않으면 새로 생성하여 반환
    static func fetchOrCreate(context: NSManagedObjectContext) -> SettingsEntity {
        let request: NSFetchRequest<SettingsEntity> = SettingsEntity.fetchRequest()
        if let settings = (try? context.fetch(request))?.first {
            return settings
        } else {
            let newSettings = SettingsEntity(context: context)
            newSettings.cash = 0.0
            newSettings.threshold = 12.0
            return newSettings
        }
    }
}


//StockEntity+CoreDataClass.swift
import Foundation
import CoreData

@objc(StockEntity)
public class StockEntity: NSManagedObject {

}


//MyPortfolioApp.swift
import SwiftUI

@main
struct MyPortfolioApp: App {
    let persistenceController = PersistenceController.shared
    
    init() {
        NotificationManager.shared.requestAuthorization()
        BackgroundTaskManager.shared.registerBackgroundTask()
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.managedObjectContext, persistenceController.container.viewContext)
                .onReceive(NotificationCenter.default.publisher(for: UIApplication.didEnterBackgroundNotification)) { _ in
                    // 앱이 백그라운드에 들어갈 때 작업 예약
                    BackgroundTaskManager.shared.scheduleAppRefresh()
                }
        }
    }
}


//StockRefreshOperation.swift
import Foundation

final class StockRefreshOperation: Operation, @unchecked Sendable {
    override func main() {
        if self.isCancelled { return }
        
        let context = PersistenceController.shared.container.newBackgroundContext()
        let stockStore = StockStore(context: context)
        
        // API 키(토큰 등)를 미리 받아둠
        var keys: APIKeys?
        let keyGroup = DispatchGroup()
        keyGroup.enter()
        Task {
            keys = await getKey()
            keyGroup.leave()
        }
        keyGroup.wait()
        guard let keys = keys else { return }
        
        let group = DispatchGroup()
        for i in stockStore.stocks.indices {
            group.enter()
            let code = stockStore.stocks[i].code
            Task {
                let (price, variation) = await StockPriceFetcher.fetchCurrentPrice(for: code, using: keys)
                if price > 0 {
                    stockStore.stocks[i].currentPrice = price
                    stockStore.stocks[i].dailyVariation = variation
                }
                group.leave()
            }
        }
        
        group.wait()
        stockStore.save()
        
        NotificationManager.shared.scheduleNotificationIfNeeded(stockStore: stockStore)
    }
}


//StockEditData.swift
import Foundation

struct StockEditData: Identifiable, Hashable {
    var id: UUID
    // 이름과 현재가는 API를 통해 가져올 것이므로 빈 문자열로 초기화하거나, 기존 주식 수정 시 참고용으로만 사용합니다.
    var name: String
    var code: String         // 종목 코드 (문자열)
    var targetPercentage: String
    var currentPrice: String // 실제 입력은 받지 않으므로 무시됨
    var quantity: String           // 정수 입력값을 문자열로 관리
    var category: String           // "주식" 또는 "현금 및 채권"
    var dailyVariation: Double
    
    init(stock: Stock?) {
        if let stock = stock {
            self.id = stock.id
            // API를 통해 최신 정보를 가져올 것이므로 기존 값은 참고용으로만 남겨둡니다.
            self.name = stock.name
            self.code = stock.code
            self.targetPercentage = String(stock.targetPercentage)
            self.currentPrice = String(stock.currentPrice)
            self.quantity = String(stock.quantity)
            self.category = stock.category
            self.dailyVariation = stock.dailyVariation
        } else {
            self.id = UUID()
            self.name = ""
            self.code = ""
            self.targetPercentage = ""
            self.currentPrice = ""
            self.quantity = ""
            self.category = "주식"
            self.dailyVariation = 0.0
        }
    }
    
    /// 이 함수는 더 이상 사용하지 않고, 저장 시 API로 값을 채운 후 Stock 객체를 생성합니다.
    func toStock() -> Stock? {
        if let target = Double(targetPercentage),
           let price = Int(currentPrice),
           let qty = Int(quantity),
           !code.isEmpty {
            return Stock(id: id, name: name, code: code, targetPercentage: target, currentPrice: price, quantity: qty, category: category, dailyVariation: 0.0)
        }
        return nil
    }
}


//NotificationManager.swift
import UserNotifications

class NotificationManager {
    static let shared = NotificationManager()
    
    /// 알림 권한 요청
    func requestAuthorization() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            if let error = error {
                print("알림 권한 요청 오류: \(error.localizedDescription)")
            } else {
                print("알림 권한 요청 결과: \(granted)")
            }
        }
    }
    
    /// 최대 변동율(maxChange)을 포함하여 리밸런싱 필요 알림 예약 (예시로 5초 후 발송)
    func scheduleRebalancingNotification(maxChange: Double) {
        let content = UNMutableNotificationContent()
        
        content.title = "리밸런싱 필요 알림"
        content.body = "일부 주식의 변동율이 기준을 초과했습니다. 현재 증감율이 \(String(format: "%.1f", maxChange))% 입니다. 리밸런싱을 고려하세요."
        content.sound = .default
        
        // 테스트용: 5초 후에 알림 발송
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
        let request = UNNotificationRequest(identifier: UUID().uuidString,
                                            content: content,
                                            trigger: trigger)
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("알림 예약 오류: \(error)")
            }
        }
    }

    /// 전체 목표 비율 오류 알림 예약 (예시로 5초 후 발송)
    func scheduleCombinedTargetNotification(combinedTarget: Double) {
        let content = UNMutableNotificationContent()
        
        content.title = "목표 비율 설정 오류"
        content.body = "전체 목표 비율 합계가 \(String(format: "%.1f", combinedTarget))%입니다.\n100%로 설정해 주세요."
        content.sound = .default
        
        // 테스트용: 5초 후에 알림 발송
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
        let request = UNNotificationRequest(identifier: UUID().uuidString,
                                            content: content,
                                            trigger: trigger)
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("알림 예약 오류: \(error)")
            }
        }
    }

    /// StockStore의 데이터를 확인하여 조건에 따라 알림 예약을 수행합니다.
    func scheduleNotificationIfNeeded(stockStore: StockStore) {
        // 전체 목표 비율의 합계가 100%가 아닌 경우 우선 알림을 실행합니다.
        if abs(stockStore.combinedTarget - 100) > 0.001 {
            scheduleCombinedTargetNotification(combinedTarget: stockStore.combinedTarget)
            return
        }
        
        // 리밸런싱이 필요한 경우 알림을 실행합니다.
        let maxChange = stockStore.maxChange
        if stockStore.needRebalance {
            scheduleRebalancingNotification(maxChange: maxChange)
        } else {
            print("리밸런싱 조건 미충족: maxChange(\(maxChange))가 threshold(\(stockStore.threshold)) 미만입니다.")
        }
    }

}


//BackgroundTaskManager.swift
import BackgroundTasks

class BackgroundTaskManager {
    static let shared = BackgroundTaskManager()
    private let refreshTaskIdentifier = "com.myportfolio.refresh"
    
    /// 앱 실행 시 백그라운드 작업 등록
    func registerBackgroundTask() {
        print("앱 실행 백그라운드 작업 등록")
        BGTaskScheduler.shared.register(forTaskWithIdentifier: refreshTaskIdentifier, using: nil, launchHandler: { task in
            print("등록된 백그라운드 작업 시작")
            self.handleAppRefresh(task: task as! BGAppRefreshTask)
        })
    }
    
    func nextTime() -> Date? {
        // 현재로부터 최소 3600초 후(1시간 후)부터 실행하도록 설정
        return Date().addingTimeInterval(60)
    }
    
    func isMarketHours(date: Date) -> Bool {
        let hour = Calendar.current.component(.hour, from: date)
        let weekday = Calendar.current.component(.weekday, from: date)

        // 주식 시장 개장 시간: 09:00 ~ 16:00 (4시)
        let isWithinMarketHours = hour >= 9 && hour < 16
        let isWeekday = weekday != 1 && weekday != 7 // 1: 일요일, 7: 토요일

        return isWeekday && isWithinMarketHours
    }
    
    /// 백그라운드 작업 예약
    func scheduleAppRefresh() {
        let request = BGAppRefreshTaskRequest(identifier: refreshTaskIdentifier)
        request.earliestBeginDate = nextTime()
        do {
            try BGTaskScheduler.shared.submit(request)
            print("백그라운드 작업 예약 성공: \(request.earliestBeginDate!)")
        } catch {
            print("백그라운드 작업 예약 실패: \(error)")
        }
    }
    
    /// 백그라운드 작업 처리
    func handleAppRefresh(task: BGAppRefreshTask) {
        print("백그라운드 작업 시작")
        scheduleAppRefresh() // 다음 작업 예약 (반복)
        
        if !isMarketHours(date: Date()) {
            print("현재 시간은 주식 시장 개장 시간이 아닙니다. 작업을 건너뜁니다.")
            task.setTaskCompleted(success: true)
            return
        }
        
        let queue = OperationQueue()
        queue.maxConcurrentOperationCount = 1
        
        // Stock 데이터 업데이트 및 알림 예약을 수행하는 커스텀 Operation
        let operation = StockRefreshOperation()
        
        // 작업 만료 시 모든 작업 취소
        task.expirationHandler = {
            queue.cancelAllOperations()
        }
        
        operation.completionBlock = {
            task.setTaskCompleted(success: !operation.isCancelled)
        }
        queue.addOperation(operation)
    }
}


//Key.swift
import Foundation

/// API 키들을 담는 구조체
struct APIKeys {
    let token: String
    let appKey: String
    let appSecret: String
}

/// 접근 토큰 응답 모델 (API 스펙에 맞게 키를 정확히 일치)
struct AccessTokenResponse: Codable {
    let accessToken: String
    let tokenType: String
    let expiresIn: Int
    let tokenExpired: String

    enum CodingKeys: String, CodingKey {
        case accessToken = "access_token"
        case tokenType   = "token_type"
        case expiresIn   = "expires_in"
        case tokenExpired = "access_token_token_expired"
    }
}

/// KeyManager 싱글톤: 토큰 발급, 저장 및 앱 키/시크릿 관리를 담당
class KeyManager {
    static let shared = KeyManager()
    
    private let tokenKey = "accessToken"
    /// 기존의 tokenTimestampKey 대신 tokenExpirationKey에 만료 시각을 저장
    private let tokenExpirationKey = "accessTokenExpiration"
    
    private let appKeyKey = "appKey"
    private let appSecretKey = "appSecret"
    
    // UserDefaults를 통한 앱 키와 앱 시크릿 (기본값: "appKey", "appSecret")
    var appKey: String {
        get { UserDefaults.standard.string(forKey: appKeyKey) ?? "appKey" }
        set { UserDefaults.standard.set(newValue, forKey: appKeyKey) }
    }
    var appSecret: String {
        get { UserDefaults.standard.string(forKey: appSecretKey) ?? "appSecret" }
        set { UserDefaults.standard.set(newValue, forKey: appSecretKey) }
    }
    
    // 접근 토큰 발급 API URL
    private let tokenURL = "https://openapi.koreainvestment.com:9443/oauth2/tokenP"
    
    private init() {}
    
    /// 저장된 토큰이 있으면 만료 시각을 체크 후 반환, 없으면 새로 발급
    func getValidToken() async -> String? {
        let defaults = UserDefaults.standard
        if let token = defaults.string(forKey: tokenKey),
           let expiration = defaults.object(forKey: tokenExpirationKey) as? Date {
            // 현재 시각이 만료 시각 이전이면 기존 토큰 사용
            if Date() < expiration {
                return token
            }
        }
        // 토큰이 없거나 만료되었으면 새 토큰 발급
        if let newToken = await fetchAccessToken() {
            return newToken
        }
        return nil
    }
    
    /// 새 접근 토큰을 API를 통해 발급하고, 만료 시각을 저장
    private func fetchAccessToken() async -> String? {
        guard let url = URL(string: tokenURL) else { return nil }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json; charset=UTF-8", forHTTPHeaderField: "Content-Type")
        
        let body: [String: String] = [
            "grant_type": "client_credentials",
            "appkey": appKey,
            "appsecret": appSecret
        ]
        
        do {
            request.httpBody = try JSONEncoder().encode(body)
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse,
                  (200...299).contains(httpResponse.statusCode) else {
                return nil
            }
            let decoder = JSONDecoder()
            let tokenResponse = try decoder.decode(AccessTokenResponse.self, from: data)
            
            // tokenExpired를 Date로 파싱 (ISO8601 형식으로 가정)
            let expirationString = tokenResponse.tokenExpired
            let formatter = ISO8601DateFormatter()
            let defaults = UserDefaults.standard
            if let expirationDate = formatter.date(from: expirationString) {
                defaults.set(tokenResponse.accessToken, forKey: tokenKey)
                defaults.set(expirationDate, forKey: tokenExpirationKey)
            } else {
                // 파싱 실패 시 expiresIn(초) 값을 기준으로 만료 시각 계산
                let expirationDate = Date().addingTimeInterval(TimeInterval(tokenResponse.expiresIn))
                defaults.set(tokenResponse.accessToken, forKey: tokenKey)
                defaults.set(expirationDate, forKey: tokenExpirationKey)
            }
            
            return tokenResponse.accessToken
        } catch {
            return nil
        }
    }
    
    /// 공개 프로퍼티: 저장된 토큰 만료 시각 (UI 참고용)
    var tokenExpirationDate: Date? {
        return UserDefaults.standard.object(forKey: tokenExpirationKey) as? Date
    }
}

/// 비동기적으로 유효한 토큰과 앱 키, 앱 시크릿을 포함하는 APIKeys를 반환
func getKey() async -> APIKeys {
    let token = await KeyManager.shared.getValidToken() ?? ""
    return APIKeys(token: token, appKey: KeyManager.shared.appKey, appSecret: KeyManager.shared.appSecret)
}


//Stock.swift
import Foundation
import SwiftUI

struct Stock: Identifiable, Equatable, Codable {
    let id: UUID
    var name: String
    var code: String               // 종목 코드 (숫자만 저장됨)
    var targetPercentage: Double   // 목표 비율 (예: 20, 30, 50)
    var currentPrice: Int          // 현재 주가 (정수)
    var quantity: Int              // 보유 주식 수 (정수)
    var category: String           // "주식" 또는 "현금 및 채권"
    
    var currentValue: Double {
        Double(currentPrice * quantity)
    }
    
    var dailyVariation: Double = 0.0 // 전일 대비 변동 백분율 (예: 1.23, -0.56 등)
    var variationColor: Color { // 전일 대비 변동률에 대한 색상
        if dailyVariation > 0 {
            return .red
        } else if dailyVariation < 0 {
            return .blue
        } else {
            return .gray
        }
    }
}

extension Stock {
    // 외부에서 전체 자산과 리밸런싱 기준(threshold)을 설정할 수 있도록 static 프로퍼티들 추가
    static var totalAssets: Double = 0.0
    
    /// 주식의 이상적인 보유 수량을 계산하는 computed property
    /// Stock.overallTotalForRebalancing 값이 이미 설정되어 있다고 가정함.
    var desiredQuantity: Int {
        let overallTotal = Stock.totalAssets
        guard currentPrice > 0, overallTotal > 0 else { return 0 }
        return Int((overallTotal * (targetPercentage / 100) / Double(currentPrice)).rounded())
    }
    
    /// 전체 자산을 전달받아 현재 주식의 가치가 전체에서 차지하는 비율(%)을 계산합니다.
    var currentPercentage: Double {
        let overallTotal = Stock.totalAssets
        guard overallTotal > 0 else { return 0.0 }
        return Double(currentPrice * quantity) / overallTotal * 100
    }
    
    /// 전체 자산을 전달받아 목표 대비 증감율(%)을 계산합니다.
    var changeRate: Double {
        let cp = currentPercentage
        guard targetPercentage > 0 else { return 0.0 }
        return (cp - targetPercentage) / targetPercentage * 100
    }
    
    /// 전체 자산을 전달받아 현재 보유 수량과 목표 수량의 차이(조정 필요 수량)를 계산합니다.
    var adjustment: Int {
        return desiredQuantity - quantity
    }
}


//StockStore.swift
import SwiftUI
import CoreData

class StockStore: ObservableObject {
    @Published var stocks: [Stock] = []
    @Published var cash: Double = 0.0
    @Published var threshold: Double = 12.0
    
    /// 모든 주식의 목표 비율 합계 계산
    var combinedTarget: Double {
        stocks.map { $0.targetPercentage }.reduce(0, +)
    }
    
    /// 전체 자산 = 모든 주식의 현재 가치 합계 + 현금
    var totalAssets: Double {
        stocks.map { $0.currentValue }.reduce(0, +) + cash
    }
    
    var maxChange: Double {
        // 각 주식의 changeRate(withOverallTotal:) 값을 절대값으로 변환한 후 최대값을 구함.
        return stocks.map { abs($0.changeRate) }.max() ?? 0.0
    }
    
    var needRebalance: Bool {
        return maxChange > threshold
    }
    
    /// 현금 비중을 숫자(%)로 계산 (전체 자산 대비 현금의 비율)
    var cashPercentage: Double {
        guard totalAssets > 0 else { return 0.0 }
        return cash / totalAssets * 100
    }
    
    private let context: NSManagedObjectContext
    private var settings: SettingsEntity?
    
    init(context: NSManagedObjectContext = PersistenceController.shared.container.viewContext) {
        self.context = context
        load()
        // 메인 컨텍스트의 변경을 감지하면 load()를 호출하여 published 프로퍼티를 업데이트합니다.
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(contextDidChange(_:)),
                                               name: NSNotification.Name.NSManagedObjectContextObjectsDidChange,
                                               object: context)
    }
    
    @objc private func contextDidChange(_ notification: Notification) {
        DispatchQueue.main.async {
            self.load()
        }
    }
    
    /// 선택된 주식들에 대해 리밸런싱을 수행하는 함수 (Stock의 desiredQuantity computed property 사용)
    func rebalanceStocks(selectedIDs: Set<Stock.ID>) {
        let pastTotal = self.totalAssets
        for index in stocks.indices {
            if selectedIDs.contains(stocks[index].id) {
                let stock = stocks[index]
                if stock.targetPercentage == 0 || stock.currentPrice <= 0 {
                    stocks[index].quantity = 0
                } else {
                    stocks[index].quantity = stock.desiredQuantity
                }
            }
        }
        self.cash = pastTotal - stocks.map { $0.currentValue }.reduce(0, +)
        save()
    }
    
    /// API를 통해 각 주식의 현재 가격, 변동률, 주식 이름을 업데이트하는 비동기 함수
    func updateStockPrices() async {
        let keys = await getKey()
        for i in stocks.indices {
            let code = stocks[i].code
            async let priceResult = StockPriceFetcher.fetchCurrentPrice(for: code, using: keys)
            async let fetchedName = StockPriceFetcher.fetchStockName(for: code, using: keys)
            let (result, name) = await (priceResult, fetchedName)
            if result.price > 0 {
                stocks[i].currentPrice = result.price
                stocks[i].dailyVariation = result.variation
            }
            stocks[i].name = name
        }
        save()
    }
    
    func load() {
        let request: NSFetchRequest<StockEntity> = StockEntity.fetchRequest()
        do {
            let stockEntities = try context.fetch(request)
            if stockEntities.isEmpty {
                self.stocks = defaultStocks()
                // defaultStocks의 각 항목을 Core Data에 추가
                for stock in self.stocks {
                    let entity = StockEntity(context: context)
                    entity.update(from: stock)
                }
                try context.save()
            } else {
                self.stocks = stockEntities.map { $0.toStock }
            }
        } catch {
            print("Error fetching stocks: \(error)")
            self.stocks = []
        }
        
        // SettingsEntity 불러오기 또는 생성
        self.settings = SettingsEntity.fetchOrCreate(context: context)
        self.cash = settings?.cash ?? 0.0
        self.threshold = settings?.threshold ?? 12.0
        
        Stock.totalAssets = self.totalAssets
    }
    
    func save() {
        // 기존 StockEntity들을 삭제하기 위해 NSBatchDeleteRequest를 사용합니다.
        let fetchRequest: NSFetchRequest<NSFetchRequestResult> = StockEntity.fetchRequest()
        let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)
        deleteRequest.resultType = .resultTypeObjectIDs
        
        do {
            if let result = try context.execute(deleteRequest) as? NSBatchDeleteResult,
               let objectIDs = result.result as? [NSManagedObjectID] {
                let changes = [NSDeletedObjectsKey: objectIDs]
                let mainContext = PersistenceController.shared.container.viewContext
                NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [mainContext])
            }
        } catch {
            print("Error deleting old stocks: \(error)")
        }
        
        // stocks 배열의 각 항목을 새 StockEntity로 추가
        for stock in stocks {
            let entity = StockEntity(context: context)
            entity.update(from: stock)
        }
        
        // Settings 업데이트
        settings?.cash = cash
        settings?.threshold = threshold
        
        do {
            try context.save()
            // 저장 후 전체 자산을 반영하여 총 자산 업데이트
            Stock.totalAssets = self.totalAssets
        } catch {
            print("Error saving context: \(error)")
        }
    }
    
    func resetData() {
        self.stocks = defaultStocks()
        self.cash = 234000
        self.threshold = 12.0
        save()
    }
    
    func defaultStocks() -> [Stock] {
        return [
            Stock(id: UUID(), name: "KODEX 200TR", code: "278530", targetPercentage: 20, currentPrice: 11780, quantity: 965, category: "주식", dailyVariation: 0.0),
            Stock(id: UUID(), name: "코리안리", code: "003690", targetPercentage: 10, currentPrice: 8240, quantity: 681, category: "주식", dailyVariation: 0.0),
            Stock(id: UUID(), name: "맥쿼리인프라", code: "088980", targetPercentage: 16, currentPrice: 10500, quantity: 788, category: "주식", dailyVariation: 0.0),
            Stock(id: UUID(), name: "ACE KRX금현물", code: "411060", targetPercentage: 14, currentPrice: 18975, quantity: 434, category: "주식", dailyVariation: 0.0),
            Stock(id: UUID(), name: "ACE 미국30년국채액티브", code: "476760", targetPercentage: 8, currentPrice: 10065, quantity: 434, category: "현금 및 채권", dailyVariation: 0.0),
            Stock(id: UUID(), name: "ACE 26-06 회사채", code: "461270", targetPercentage: 15, currentPrice: 10945, quantity: 751, category: "현금 및 채권", dailyVariation: 0.0),
            Stock(id: UUID(), name: "TIGER 27-04회사채", code: "480260", targetPercentage: 17, currentPrice: 52430, quantity: 178, category: "현금 및 채권", dailyVariation: 0.0)
        ]
    }
}


//FormatterHelper.swift
import Foundation

struct FormatterHelper {
    // 화면에 표시할 때 쉼표가 포함된 형식 (예: 50,000,000)
    static let displayCurrency: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 0
        formatter.usesGroupingSeparator = true
        formatter.groupingSize = 3
        formatter.secondaryGroupingSize = 3
        return formatter
    }()
    
    // 입력 시에는 쉼표 없이 숫자만 보이도록
    static let editingCurrency: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 0
        formatter.usesGroupingSeparator = false
        return formatter
    }()
    
    // 리밸런싱 기준 증감율 입력용 포매터 (정수와 실수 모두 허용)
    static let thresholdFormatter: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 2
        formatter.minimumFractionDigits = 0
        return formatter
    }()
}


//StockPriceFetcher.swift
import Foundation

// MARK: - 현재가 조회 관련 모델
struct InquiryPriceOutput: Codable {
    let stck_prpr: String   // 현재가 (문자열)
    let prdy_ctrt: String   // 전일 대비 백분율 (문자열, 예: "1.23", "-0.56")
}

struct InquiryPriceResponse: Codable {
    let output: InquiryPriceOutput
}

// MARK: - 주식 이름(상품명) 조회 관련 모델
struct StockNameOutput: Codable {
    let prdt_abrv_name: String   // 상품명 (주식 이름)
}

struct StockNameResponse: Codable {
    let output: StockNameOutput
}

struct StockPriceFetcher {
    // 가격 조회 API 상수
    static let trIDPrice = "FHKST01010100"
    static let basePriceURL = "https://openapi.koreainvestment.com:9443/uapi/domestic-stock/v1/quotations/inquire-price"
    static let marketDivCode = "J"
    
    // 주식 이름 조회 API 상수
    static let trIDStockName = "CTPF1604R"
    static let baseStockNameURL = "https://openapi.koreainvestment.com:9443/uapi/domestic-stock/v1/quotations/search-info"
    
    /// 현재가와 전일 대비 백분율을 함께 반환하는 함수
    /// - Parameters:
    ///   - code: 주식 종목 코드
    ///   - keys: 미리 받아둔 APIKeys (토큰, appKey, appSecret)
    /// - Returns: (price, variation) 튜플
    static func fetchCurrentPrice(for code: String, using keys: APIKeys) async -> (price: Int, variation: Double) {
        let query = "?FID_COND_MRKT_DIV_CODE=\(marketDivCode)&FID_INPUT_ISCD=\(code)"
        guard let url = URL(string: basePriceURL + query) else {
            return (0, 0.0)
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        request.setValue("Bearer \(keys.token)", forHTTPHeaderField: "authorization")
        request.setValue(keys.appKey, forHTTPHeaderField: "appKey")
        request.setValue(keys.appSecret, forHTTPHeaderField: "appSecret")
        request.setValue(trIDPrice, forHTTPHeaderField: "tr_id")
        
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse,
                  (200...299).contains(httpResponse.statusCode) else {
                return (0, 0.0)
            }
            let decoder = JSONDecoder()
            let priceResponse = try decoder.decode(InquiryPriceResponse.self, from: data)
            let price = Int(priceResponse.output.stck_prpr) ?? 0
            let variation = Double(priceResponse.output.prdy_ctrt) ?? 0.0
            return (price, variation)
        } catch {
            return (0, 0.0)
        }
    }
    
    /// 주식 이름(상품명)을 가져오는 함수
    /// - Parameters:
    ///   - code: 주식 종목 코드
    ///   - keys: 미리 받아둔 APIKeys
    /// - Returns: 주식 이름 (실패 시 빈 문자열)
    static func fetchStockName(for code: String, using keys: APIKeys) async -> String {
        let query = "?PDNO=\(code)&PRDT_TYPE_CD=300"
        guard let url = URL(string: baseStockNameURL + query) else {
            return ""
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
        
        request.setValue("Bearer \(keys.token)", forHTTPHeaderField: "authorization")
        request.setValue(keys.appKey, forHTTPHeaderField: "appKey")
        request.setValue(keys.appSecret, forHTTPHeaderField: "appSecret")
        request.setValue(trIDStockName, forHTTPHeaderField: "tr_id")
        request.setValue("P", forHTTPHeaderField: "custtype")
        
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse,
                  (200...299).contains(httpResponse.statusCode) else {
                return ""
            }
            let decoder = JSONDecoder()
            let stockNameResponse = try decoder.decode(StockNameResponse.self, from: data)
            return stockNameResponse.output.prdt_abrv_name
        } catch {
            return ""
        }
    }
}


//PersistenceController.swift
import CoreData

struct PersistenceController {
    static let shared = PersistenceController()
    
    let container: NSPersistentContainer
    
    init(inMemory: Bool = false) {
        container = NSPersistentContainer(name: "MyPortfolioModel") // xcdatamodeld 파일 이름과 동일하게 설정
        if inMemory {
            container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: "/dev/null")
        }
        container.loadPersistentStores { storeDescription, error in
            if let error = error as NSError? {
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }
        container.viewContext.automaticallyMergesChangesFromParent = true
    }
}


//SettingsView.swift
import SwiftUI

struct SettingsView: View {
    @EnvironmentObject var store: StockStore
    /// 탭 선택 상태에 대한 Binding (데이터 초기화 후 포트폴리오 탭(인덱스 0)으로 전환)
    @Binding var selectedTab: Int
    @State private var showAPIKeySettings: Bool = false
    
    private var tokenExpirationText: String {
        if let expiration = KeyManager.shared.tokenExpirationDate {
            let formatted = expiration.formatted(date: .abbreviated, time: .shortened)
            return "토큰 만료 시각: \(formatted)"
        } else {
            return "토큰 만료 시각: 없음"
        }
    }
    
    var body: some View {
        NavigationStack {
            Form {
                Section(header: Text("설정")) {
                    HStack {
                        Text("리밸런싱 기준 증감율")
                        TextField("예: 12.0", value: $store.threshold, formatter: FormatterHelper.thresholdFormatter)
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                            .onChange(of: store.threshold) {
                                store.save()
                            }
                    }

                    
                    VStack(alignment: .leading, spacing: 4) {
                        Button("API Key") {
                            showAPIKeySettings = true
                        }
                        .foregroundColor(.blue)
                        
                        Text(tokenExpirationText)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                // 데이터 초기화 섹션
                Section {
                    Button("데이터 초기화") {
                        store.resetData()
                        // 데이터 초기화 후 포트폴리오 탭(인덱스 0)으로 전환
                        selectedTab = 0
                    }
                    .foregroundColor(.red)
                }
            }
            .navigationTitle("설정")
            .sheet(isPresented: $showAPIKeySettings) {
                NavigationStack {
                    APIKeySettingsView()
                }
            }
        }
    }
}

struct SettingsView_Previews: PreviewProvider {
    static var previews: some View {
        // 프리뷰에서는 임의의 탭 선택 Binding을 사용합니다.
        SettingsView(selectedTab: .constant(2))
            .environmentObject(StockStore())
    }
}


//CashEditView.swift
import SwiftUI

struct CashEditView: View {
    /// StockStore의 cash 값과 바인딩 (필요에 따라 EnvironmentObject를 사용할 수도 있음)
    @Binding var cash: Double
    @Environment(\.dismiss) var dismiss
    @State private var editedCash: String = ""
    
    var body: some View {
        NavigationStack {
            Form {
                Section(header: Text("현금 수정")) {
                    TextField("현금 입력", text: $editedCash)
                        .keyboardType(.numbersAndPunctuation)
                }
            }
            .navigationTitle("현금 수정")
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("저장") {
                        // 입력된 문자열이 정수로 변환 가능한 경우에만 cash를 업데이트
                        if let newCashInt = Int(editedCash) {
                            cash = Double(newCashInt)
                        }
                        dismiss()
                    }
                }
                ToolbarItem(placement: .cancellationAction) {
                    Button("취소") {
                        dismiss()
                    }
                }
            }
            .onAppear {
                // 현금 값을 String으로 변환하여 초기값으로 설정 (정수로 보이게 하기 위해 Int로 변환)
                editedCash = String(Int(cash))
            }
        }
    }
}


//StockAddView.swift
import SwiftUI

struct StockAddView: View {
    @State var addData: StockEditData  // 기존 StockEditData를 재사용
    var onCancel: () -> Void
    var onSave: (Stock) -> Void
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("새 주식 정보 입력")) {
                    Picker("종목 유형", selection: $addData.category) {
                        Text("주식").tag("주식")
                        Text("현금 및 채권").tag("현금 및 채권")
                    }
                    .pickerStyle(SegmentedPickerStyle())
                    
                    HStack {
                        Text("종목 코드")
                        TextField("예: 278530", text: $addData.code)
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                    }
                    
                    HStack {
                        Text("목표 비율")
                        TextField("예: 20.0", text: $addData.targetPercentage)
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                    }
                    
                    HStack {
                        Text("보유 수량")
                        TextField("예: 10", text: $addData.quantity)
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                    }
                }
            }
            .navigationTitle("주식 추가")
            .navigationBarItems(
                leading: Button("취소") { onCancel() },
                trailing: Button("저장") { saveStock() }
            )
        }
    }
    
    private func saveStock() {
        Task {
            // API 키를 미리 받아서 재사용
            let keys = await getKey()
            let (price, variation) = await StockPriceFetcher.fetchCurrentPrice(for: addData.code, using: keys)
            let name = await StockPriceFetcher.fetchStockName(for: addData.code, using: keys)
            
            guard let target = Double(addData.targetPercentage),
                  let qty = Int(addData.quantity) else {
                return
            }
            
            let stock = Stock(
                id: addData.id,
                name: name,
                code: addData.code,
                targetPercentage: target,
                currentPrice: price,
                quantity: qty,
                category: addData.category,
                dailyVariation: variation
            )
            
            await MainActor.run {
                onSave(stock)
            }
        }
    }
}

struct StockAddView_Previews: PreviewProvider {
    static var previews: some View {
        StockAddView(addData: StockEditData(stock: nil),
                     onCancel: {},
                     onSave: { stock in
                         print("저장된 주식: \(stock)")
                     })
    }
}


//StockRowView.swift
import SwiftUI

struct StockRowView: View {
    let stock: Stock
    let overallTotal: Double
    var onEdit: () -> Void
    var onDelete: () -> Void
    
    var body: some View {
        return HStack(alignment: .bottom) {
            VStack(alignment: .leading, spacing: 4) {
                Text(stock.name)
                    .font(.body)
                    .lineLimit(1)
                    .truncationMode(.tail)
                Text(stock.code)
                    .font(.caption2)
                    .foregroundColor(.gray)
                HStack(spacing: 0) {
                    Text("\(stock.currentPrice)원 ")
                    Text("(")
                        .foregroundColor(.gray)
                    Text("\(stock.dailyVariation, specifier: "%.2f")%")
                        .foregroundColor(stock.variationColor)
                    Text(")")
                        .foregroundColor(.gray)
                }
                .font(.caption2)
            }
            Spacer()
            VStack(alignment: .trailing, spacing: 2) {
                Text("현재: \(stock.currentPercentage, specifier: "%.1f")%")
                    .font(.caption)
                    .foregroundColor(.gray)
                Text("목표: \(stock.targetPercentage, specifier: "%.1f")%")
                    .font(.caption)
                    .foregroundColor(.gray)
                (Text(String(format: "%+6.1f", stock.changeRate) + "%")
                    .monospacedDigit()
                    .foregroundColor(stock.changeRate >= 0 ? .red : .blue)
                +
                Text(" | ")
                    .foregroundStyle(.secondary)
                +
                Text(String(format: "%+d", stock.adjustment))
                    .monospacedDigit()
                +
                Text("주"))
                    .lineLimit(1)
                    .truncationMode(.head)
            }
        }
        .contentShape(Rectangle())
    }
}

struct StockRowView_Previews: PreviewProvider {
    static var previews: some View {
        // 미리보기에서는 임의의 전체 자산 값을 전달합니다.
        StockRowView(
            stock: Stock(id: UUID(),
                         name: "Test Stock",
                         code: "123456",
                         targetPercentage: 20,
                         currentPrice: 100,
                         quantity: 10,
                         category: "주식",
                         dailyVariation: 1.23),
            overallTotal: 10000,
            onEdit: {},
            onDelete: {}
        )
        .previewLayout(.sizeThatFits)
    }
}


//AssetStatusView.swift
import SwiftUI

struct AssetStatusView: View {
    @EnvironmentObject var store: StockStore
    /// ContentView에서 전달받은 주식 추가용 데이터 (시트용)
    @Binding var editingStockData: StockEditData?
    /// 탭 제스처로 선택한 주식 상세 데이터를 저장 (모달 시트 전환용)
    @State private var selectedDetailData: StockEditData? = nil
    /// 현금 수정 시트를 표시하기 위한 상태 변수
    @State private var showCashEdit: Bool = false
    /// 수량 전체 수정 모드 여부
    @State private var isEditingQuantity: Bool = false
    /// 편집 중인 수량을 임시로 저장 (stock.id를 key로 사용)
    @State private var editedQuantities: [UUID: String] = [:]
    /// 포커스 관리: 현재 포커스가 가야하는 주식의 id (수량 수정란)
    @FocusState private var focusedStock: UUID?
    
    var body: some View {
        NavigationStack {
            ZStack {
                Form {
                    // 상단에 총 자산 정보를 중앙 정렬하여 표시
                    HStack {
                        Spacer()
                        VStack(spacing: 4) {
                            Text("총 자산")
                                .font(.caption)
                                .foregroundColor(.gray)
                            Text("\(store.totalAssets, specifier: "%.0f")원")
                                .font(.title2)
                                .fontWeight(.bold)
                        }
                        Spacer()
                    }
                    .listRowSeparator(.hidden)
                    .listRowBackground(Color.clear)
                    
                    // [주식 섹션]
                    Section(header: Text("주식")) {
                        // 주식 섹션은 주식 코드 오름차순으로 정렬
                        let sortedStocks = store.stocks.filter { $0.category == "주식" }
                            .sorted { (s1, s2) in (Int(s1.code) ?? 0) < (Int(s2.code) ?? 0) }
                        
                        ForEach(sortedStocks) { stock in
                            assetRowView(for: stock)
                                .onTapGesture {
                                    if !isEditingQuantity {
                                        selectedDetailData = StockEditData(stock: stock)
                                    }
                                }
                                .swipeActions(edge: .trailing) {
                                    Button(role: .destructive) {
                                        if let index = store.stocks.firstIndex(where: { $0.id == stock.id }) {
                                            store.stocks.remove(at: index)
                                            store.save()
                                        }
                                    } label: {
                                        Label("삭제", systemImage: "trash")
                                    }
                                }
                        }
                    }
                    
                    // [채권 섹션]
                    Section(header: Text("채권")) {
                        ForEach(store.stocks.filter { $0.category == "현금 및 채권" }
                                    .sorted { (s1, s2) in (Int(s1.code) ?? 0) < (Int(s2.code) ?? 0) }
                        ) { asset in
                            assetRowView(for: asset)
                                .onTapGesture {
                                    if !isEditingQuantity {
                                        selectedDetailData = StockEditData(stock: asset)
                                    }
                                }
                                .swipeActions(edge: .trailing) {
                                    Button(role: .destructive) {
                                        if let index = store.stocks.firstIndex(where: { $0.id == asset.id }) {
                                            store.stocks.remove(at: index)
                                            store.save()
                                        }
                                    } label: {
                                        Label("삭제", systemImage: "trash")
                                    }
                                }
                        }
                        
                        // 현금 행 (현금은 삭제 대상이 아니므로 swipeActions 없이 표시)
                        HStack(alignment: .bottom) {
                            Text("현금")
                                .font(.body)
                            Spacer()
                            Text("\(FormatterHelper.displayCurrency.string(from: NSNumber(value: store.cash)) ?? "\(store.cash)")원")
                                .font(.body)
                                .foregroundColor(.gray)
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            showCashEdit = true
                        }
                    }
                } // Form 끝
                
                // 떠 있는 + 버튼 (새 주식 추가용)
                Button(action: {
                    editingStockData = StockEditData(stock: nil)
                }) {
                    Image(systemName: "plus")
                        .font(.title)
                        .foregroundColor(.white)
                        .frame(width: 60, height: 60)
                        .background(Color.blue)
                        .clipShape(Circle())
                        .shadow(radius: 4)
                }
                .padding()
                .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottomTrailing)
            } // ZStack 끝
            .navigationTitle("자산 현황")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    if isEditingQuantity {
                        Button("완료") {
                            // 입력한 수량을 저장
                            for index in store.stocks.indices {
                                let stock = store.stocks[index]
                                if let newQuantityString = editedQuantities[stock.id],
                                   let newQuantity = Int(newQuantityString) {
                                    store.stocks[index].quantity = newQuantity
                                }
                            }
                            store.save()
                            // 편집 모드 종료 및 임시 데이터 초기화
                            isEditingQuantity = false
                            editedQuantities = [:]
                            focusedStock = nil
                        }
                    } else {
                        Menu {
                            Button("수량 전체 수정") {
                                // 각 주식의 현재 수량을 임시 저장 후 편집 모드 활성화
                                for stock in store.stocks {
                                    editedQuantities[stock.id] = "\(stock.quantity)"
                                }
                                isEditingQuantity = true
                                
                                // 주식 섹션에서 주식 코드 기준 오름차순 정렬 후 첫 번째 주식에 포커스 부여
                                let sortedStocks = store.stocks.filter { $0.category == "주식" }
                                    .sorted { (s1, s2) in (Int(s1.code) ?? 0) < (Int(s2.code) ?? 0) }
                                if let firstStock = sortedStocks.first {
                                    focusedStock = firstStock.id
                                }
                            }
                        } label: {
                            Image(systemName: "ellipsis")
                                .imageScale(.large)
                        }
                    }
                }
            }
            // 주식 상세 데이터 모달 시트 (편집 모드가 아닐 때)
            .sheet(item: $selectedDetailData) { detail in
                StockDetailView(
                    detailData: detail,
                    onSave: { updatedStock in
                        if let index = store.stocks.firstIndex(where: { $0.id == updatedStock.id }) {
                            store.stocks[index] = updatedStock
                        }
                        store.save()
                    }
                )
            }
            // 현금 수정 시트를 위한 모달 시트
            .sheet(isPresented: $showCashEdit) {
                CashEditView(cash: $store.cash)
            }
            // 주식 추가 시트
            .sheet(isPresented: Binding<Bool>(
                get: { editingStockData != nil && (editingStockData?.name.isEmpty ?? true) },
                set: { if !$0 { editingStockData = nil } }
            )) {
                if let addData = editingStockData {
                    StockAddView(
                        addData: addData,
                        onCancel: { editingStockData = nil },
                        onSave: { newStock in
                            store.stocks.append(newStock)
                            store.save()
                            editingStockData = nil
                        }
                    )
                }
            }
        } // NavigationStack 끝
    }
    
    /// 주식/채권 행을 구성하는 뷰 (좌측: 이름, 코드, 현재가(전일대비); 우측: 보유 수량, 평가 금액)
    @ViewBuilder
    private func assetRowView(for stock: Stock) -> some View {
        HStack(alignment: .bottom) {
            // 왼쪽 정보 영역
            VStack(alignment: .leading, spacing: 4) {
                Text(stock.name)
                    .font(.body)
                    .lineLimit(1)
                    .truncationMode(.tail)
                Text("\(stock.code)")
                    .font(.caption2)
                    .foregroundColor(.gray)
                HStack(spacing: 0) {
                    Text("\(stock.currentPrice)원 ")
                    Text("(")
                        .foregroundColor(.gray)
                    Text("\(stock.dailyVariation, specifier: "%.2f")%")
                        .foregroundColor(stock.variationColor)
                    Text(")")
                        .foregroundColor(.gray)
                }
                .font(.caption2)
            }
            Spacer()
            // 오른쪽 정보 영역
            VStack(alignment: .trailing, spacing: 2) {
                if isEditingQuantity {
                    HStack(spacing: 2) {
                        TextField("", text: Binding(
                            get: { editedQuantities[stock.id] ?? "\(stock.quantity)" },
                            set: { editedQuantities[stock.id] = $0 }
                        ))
                        .keyboardType(.numbersAndPunctuation)
                        .frame(width: 50)
                        .focused($focusedStock, equals: stock.id)
                        Text("주")
                    }
                } else {
                    Text("\(stock.quantity)주")
                        .font(.body)
                }
                Text("\(FormatterHelper.displayCurrency.string(from: NSNumber(value: stock.currentValue)) ?? "\(stock.currentValue)")원")
                    .font(.body)
                    .foregroundColor(.gray)
            }
        }
    }
}

struct AssetStatusView_Previews: PreviewProvider {
    static var previews: some View {
        AssetStatusView(editingStockData: .constant(nil))
            .environmentObject(StockStore())
    }
}


//StockDetailView.swift
import SwiftUI

struct StockDetailView: View {
    @Environment(\.dismiss) var dismiss
    @State var detailData: StockEditData
    var onSave: (Stock) -> Void

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("주식 정보")) {
                    Picker("종목 유형", selection: $detailData.category) {
                        Text("주식").tag("주식")
                        Text("현금 및 채권").tag("현금 및 채권")
                    }
                    .pickerStyle(SegmentedPickerStyle())
                    
                    HStack {
                        Text("종목 코드")
                        TextField("예: 278530", text: $detailData.code)
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                    }
                    
                    HStack {
                        Text("목표 비율")
                        TextField("예: 20.0", text: $detailData.targetPercentage)
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                    }
                    
                    HStack {
                        Text("보유 수량")
                        TextField("예: 10", text: $detailData.quantity)
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                    }
                }
            }
            .navigationTitle(detailData.name.isEmpty ? "주식 정보" : detailData.name)
            .navigationBarItems(
                leading: Button("취소") { dismiss() },
                trailing: Button("저장") { saveStock() }
            )
        }
    }
    
    private func saveStock() {
        Task {
            // detailData의 targetPercentage, quantity, currentPrice를 문자열에서 숫자로 변환
            guard let target = Double(detailData.targetPercentage),
                  let qty = Int(detailData.quantity),
                  let currentPrice = Int(detailData.currentPrice) else {
                return
            }
            
            let stock = Stock(
                id: detailData.id,
                name: detailData.name,
                code: detailData.code,
                targetPercentage: target,
                currentPrice: currentPrice,
                quantity: qty,
                category: detailData.category,
                dailyVariation: detailData.dailyVariation
            )
            
            await MainActor.run {
                onSave(stock)
                dismiss()
            }
        }
    }
}

struct StockDetailView_Previews: PreviewProvider {
    static var previews: some View {
        StockDetailView(detailData: StockEditData(stock: nil),
                        onSave: { stock in
                            print("저장된 주식: \(stock)")
                        })
    }
}


//APIKeySettingView.swift
import SwiftUI

struct APIKeySettingsView: View {
    @State private var appKey: String = KeyManager.shared.appKey
    @State private var appSecret: String = KeyManager.shared.appSecret
    @Environment(\.presentationMode) private var presentationMode

    var body: some View {
        NavigationStack {
            Form {
                Section(header: Text("API Key")) {
                    TextField("App Key", text: $appKey)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .textInputAutocapitalization(.never)
                        .disableAutocorrection(true)
                    
                    TextField("App Secret", text: $appSecret)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .textInputAutocapitalization(.never)
                        .disableAutocorrection(true)
                }
            }
            .navigationTitle("API Key")
            .safeAreaInset(edge: .bottom) {
                Button(action: {
                    KeyManager.shared.appKey = appKey
                    KeyManager.shared.appSecret = appSecret
                    presentationMode.wrappedValue.dismiss()
                }) {
                    Text("저장")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                        .padding(.horizontal)
                }
            }
        }
    }
}

struct APIKeySettingsView_Previews: PreviewProvider {
    static var previews: some View {
        APIKeySettingsView()
    }
}


//ContentView.swift
import SwiftUI

struct ContentView: View {
    @StateObject private var store = StockStore()  // 내부에서 Core Data의 context를 사용
    @State private var selectedTab: Int = 0
    @State private var editingStockData: StockEditData? = nil
    
    var body: some View {
        TabView(selection: $selectedTab) {
            // PortfolioView는 더 이상 주식 추가용 editingStockData를 사용하지 않습니다.
            PortfolioView()
                .environmentObject(store)
                .tag(0)
                .tabItem {
                    Label("포트폴리오", systemImage: "chart.bar")
                }
            
            // AssetStatusView는 주식 추가를 위해 editingStockData 바인딩을 사용합니다.
            AssetStatusView(editingStockData: $editingStockData)
                .environmentObject(store)
                .tag(1)
                .tabItem {
                    Label("자산 현황", systemImage: "dollarsign.circle")
                }
            
            SettingsView(selectedTab: $selectedTab)
                .environmentObject(store)
                .tag(2)
                .tabItem {
                    Label("설정", systemImage: "gear")
                }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        // 미리보기에서는 inMemory 옵션 사용을 권장합니다.
        let persistenceController = PersistenceController.shared
        ContentView()
            .environment(\.managedObjectContext, persistenceController.container.viewContext)
    }
}


//PortfolioView.swift
import SwiftUI

struct PortfolioView: View {
    @EnvironmentObject var store: StockStore
    
    @State private var isSelectingStocks: Bool = false
    @State private var selectedStockIDs: Set<Stock.ID> = []
    @State private var showRebalancingWarning: Bool = false
    
    // 주식만 필터링하여 정렬
    private var stocksOnly: [Stock] {
        store.stocks.filter { $0.category == "주식" }
            .sorted { (s1, s2) in (Int(s1.code) ?? 0) < (Int(s2.code) ?? 0) }
    }
    
    // 현금 및 채권만 필터링하여 정렬
    private var bondsOnly: [Stock] {
        store.stocks.filter { $0.category == "현금 및 채권" }
            .sorted { (s1, s2) in (Int(s1.code) ?? 0) < (Int(s2.code) ?? 0) }
    }
    
    var body: some View {
        NavigationStack {
            Form {
                // 전체 목표 비율 경고 섹션
                if abs(store.combinedTarget - 100) > 0.001 {
                    Section {
                        Text("전체 목표 비율 합계가 \(store.combinedTarget, specifier: "%.1f")%입니다.\n100%로 설정해 주세요.")
                            .foregroundColor(.red)
                    }
                }
                // 현금 음수 경고 섹션
                if store.cash < 0 {
                    Section {
                        Text("현금 잔액이 음수입니다.")
                            .foregroundColor(.red)
                    }
                }
                // 리밸런싱 필요 경고 섹션
                if store.needRebalance {
                    Section {
                        Text("리밸런싱 필요")
                            .foregroundColor(.red)
                    }
                }
                
                // [주식 목록 섹션]
                Section(header: Text("주식")) {
                    ForEach(stocksOnly) { stock in
                        if isSelectingStocks {
                            HStack {
                                Image(systemName: selectedStockIDs.contains(stock.id) ? "checkmark.circle.fill" : "circle")
                                    .font(.system(size: 20))
                                    .foregroundColor(selectedStockIDs.contains(stock.id) ? .blue : .gray)
                                StockRowView(
                                    stock: stock,
                                    overallTotal: store.totalAssets,
                                    onEdit: { },
                                    onDelete: { }
                                )
                            }
                            .contentShape(Rectangle())
                            .onTapGesture {
                                if selectedStockIDs.contains(stock.id) {
                                    selectedStockIDs.remove(stock.id)
                                } else {
                                    selectedStockIDs.insert(stock.id)
                                }
                            }
                        } else {
                            StockRowView(
                                stock: stock,
                                overallTotal: store.totalAssets,
                                onEdit: { },
                                onDelete: { }
                            )
                        }
                    }
                }
                
                // [현금 및 채권 목록 섹션]
                Section(header: Text("현금 및 채권")) {
                    ForEach(bondsOnly) { stock in
                        if isSelectingStocks {
                            HStack {
                                Image(systemName: selectedStockIDs.contains(stock.id) ? "checkmark.circle.fill" : "circle")
                                    .font(.system(size: 20))
                                    .foregroundColor(selectedStockIDs.contains(stock.id) ? .blue : .gray)
                                StockRowView(
                                    stock: stock,
                                    overallTotal: store.totalAssets,
                                    onEdit: { },
                                    onDelete: { }
                                )
                            }
                            .contentShape(Rectangle())
                            .onTapGesture {
                                if selectedStockIDs.contains(stock.id) {
                                    selectedStockIDs.remove(stock.id)
                                } else {
                                    selectedStockIDs.insert(stock.id)
                                }
                            }
                        } else {
                            StockRowView(
                                stock: stock,
                                overallTotal: store.totalAssets,
                                onEdit: { },
                                onDelete: { }
                            )
                        }
                    }
                    // 현금 행: StockStore의 cashPercentage 사용 (숫자 값을 포맷팅하여 표시)
                    HStack {
                        Text("현금")
                        Spacer()
                        Text(String(format: "%.1f%%", store.cashPercentage))
                            .font(.body)
                            .foregroundColor(.gray)
                    }
                    .contentShape(Rectangle())
                }
            }
            .refreshable { await store.updateStockPrices() }
            .navigationTitle("포트폴리오")
            .toolbar {
                if isSelectingStocks {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("완료") {
                            isSelectingStocks = false
                            selectedStockIDs.removeAll()
                        }
                    }
                } else {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Menu {
                            Button("주식 선택") {
                                if store.cash < 0 || abs(store.combinedTarget - 100) > 0.001 {
                                    showRebalancingWarning = true
                                } else {
                                    isSelectingStocks.toggle()
                                }
                            }
                        } label: {
                            Image(systemName: "ellipsis")
                        }
                    }
                }
            }
            // 선택 모드일 때 하단 오버레이: 삭제 및 리밸런싱 버튼
            .overlay(
                Group {
                    if isSelectingStocks {
                        VStack {
                            Spacer()
                            HStack {
                                Button("삭제") {
                                    store.stocks.removeAll { selectedStockIDs.contains($0.id) }
                                    store.save()
                                    isSelectingStocks = false
                                    selectedStockIDs.removeAll()
                                }
                                .foregroundColor(.red)
                                .padding()
                                
                                Spacer()
                                
                                Button("리밸런싱") {
                                    store.rebalanceStocks(selectedIDs: selectedStockIDs)
                                    isSelectingStocks = false
                                    selectedStockIDs.removeAll()
                                }
                                .foregroundColor(.blue)
                                .padding()
                            }
                            .frame(maxWidth: .infinity)
                            .background(Color(UIColor.systemBackground))
                        }
                        .transition(.move(edge: .bottom))
                    }
                }
            )
            .alert("경고", isPresented: $showRebalancingWarning) {
                Button("확인", role: .cancel) { }
            } message: {
                Text("현금 잔액이 음수이거나 목표 비율 합계가 100%가 아닙니다.")
            }
        }
    }
}

struct PortfolioView_Previews: PreviewProvider {
    static var previews: some View {
        PortfolioView()
            .environmentObject(StockStore())
    }
}


